# Docker и Kubernetes

## Что такое Docker? 

**Docker** — это открытая платформа для разработки, доставки и эксплуатации приложений. Docker разработан для более быстрого выкладывания приложений. С помощью docker можно отделить  приложение от  инфраструктуры и обращаться с инфраструктурой как управляемым приложением. Docker помогает выкладывать  код быстрее, быстрее тестировать, быстрее выкладывать приложения и уменьшить время между написанием кода и запуска кода. Docker делает это с помощью легковесной платформы контейнерной виртуализации, используя процессы и утилиты, которые помогают управлять и выкладывать приложения.

В своем ядре docker позволяет запускать практически любое приложение, безопасно изолированное в контейнере. Безопасная изоляция позволяет запускать на одном хосте много контейнеров одновременно. Легковесная природа контейнера, который запускается без дополнительной нагрузки гипервизора, позволяет добиваться больше от вашего железа.

Платформа и средства контейнерной виртуализации могут быть полезны в следующих случаях:

- упаковывание приложения (и так же используемых компонент) в docker контейнеры;
- раздача и доставка этих контейнеров  командам для разработки и тестирования;
- выкладывания этих контейнеров на продакшены, как в дата центры так и в облака.

## Для чего он используется?

**1. Быстрое выкладывание  приложений**

Docker прекрасно подходит для организации цикла разработки. Docker позволяет разработчикам использовать локальные контейнеры с приложениями и сервисами. Что в последствии позволяет интегрироваться с процессом постоянной интеграции и выкладывания (continuous integration and deployment workflow).

**2. Более простое выкладывание и разворачивание**

Основанная на контейнерах docker платформа позволят легко портировать полезную нагрузку. Docker контейнеры могут работать на  локальной машине, как реальной так и на виртуальной машине в дата центре, так и в облаке.  
Портируемость и легковесная природа docker позволяет легко динамически управлять  нагрузкой.  docker можно использовать, чтобы развернуть или погасить  приложение или сервисы. Скорость docker позволяет делать это почти в режиме реального времени.

**3. Высокие нагрузки и больше полезных нагрузок**

Docker легковесен и быстр. Он предоставляет устойчивую, рентабельную альтернативу виртуальным машинам на основе гипервизора. Он особенно полезен в условиях высоких нагрузок, например, при создания собственного облака или платформа-как-сервис (platform-as-service). Но он так же полезен для маленьких и средних приложений, когда хочется получать больше из имеющихся ресурсов.

## Чем Docker отличается от виртуальной машины?

**Виртуальная машина** - это система, которая действует точно так же, как компьютер. Виртуальные машины позволяют запускать операционную систему в приложении, которое ведет себя как полноценный отдельный компьютер. Их можно использовать их для работы с различными операционными системами, запускать программное обеспечение, которое не может работать на основной ОС.

**Docker** - это инструмент, который использует контейнеры для упрощения создания, развертывания и запуска приложений. Он связывает приложение и его зависимости внутри контейнера.

### **Основные различия между виртуальной машиной и контейнером Docker.**

#### 1. **Поддержка операционной системы**
Поддержка операционной системы виртуальной машины и контейнера Docker сильно отличается. Каждая виртуальная машина имеет свою гостевую операционную систему над основной операционной системой, что делает виртуальные машины тяжелыми. С другой стороны, контейнеры Docker используют общую операционную систему хоста, и поэтому они легковесны.  
Совместное использование операционной системы хоста между контейнерами делает их очень легкими и помогает им загружаться всего за несколько секунд. Следовательно, накладные расходы на управление контейнерной системой очень низкие по сравнению с виртуальными машинами.  
Docker контейнеры подходят для ситуаций, когда вы хотите запустить несколько приложений в одном ядре операционной системы. Но если у вас есть приложения или серверы, которые должны работать в разных версиях операционной системы, тогда требуются виртуальные машины.

#### 2. **Безопасность**
Виртуальная машина не имеет общей операционной системы, и в ядре хоста существует сильная изоляция. Следовательно, они более безопасны по сравнению с контейнерами. Контейнер имеет много угроз безопасности и уязвимостей, поскольку контейнеры имеют общее ядро хоста.  
Кроме того, поскольку ресурсы докера являются общими и не имеют пространства имен, злоумышленник может использовать все контейнеры в кластере, если он получает доступ даже к одному контейнеру. В виртуальной машине вы не получаете прямого доступа к ресурсам, а гипервизор предназначен для ограничения использования ресурсов в виртуальной машине.

#### 3. **Портативность**
Контейнеры Docker легко переносимы, поскольку у них нет отдельных операционных систем. Контейнер может быть перенесен на другую ОС, и он может запуститься немедленно. С другой стороны, виртуальные машины имеют отдельную ОС, поэтому портирование виртуальной машины затруднено по сравнению с контейнерами, а также требуется много времени для портирования виртуальной машины из-за ее размера.  
Для целей разработки, где приложения должны разрабатываться и тестироваться на разных платформах, контейнеры Docker являются идеальным выбором.

#### 4. **Производительность**
Сравнение виртуальных машин и контейнеров Docker было бы несправедливым, поскольку они оба используются для разных целей. Но легкая архитектура Docker и его менее ресурсоемкая функция делают его лучшим выбором, чем виртуальная машина. В результате контейнеры могут запускаться очень быстро по сравнению с виртуальными машинами, а использование ресурсов варьируется в зависимости от нагрузки или трафика в нем.  
В отличие от виртуальных машин, нет необходимости постоянно выделять ресурсы для контейнеров. Масштабирование и дублирование контейнеров также является простой задачей по сравнению с виртуальными машинами, поскольку в них нет необходимости устанавливать операционную систему.

### **Основные различия между виртуальной машиной и контейнером Docker в таблице**
| Виртуальная машина | Docker |
| ------ |-------|
| Изоляция процесса на аппаратном уровне|Изоляция процесса на уровне ОС|
| Поддержка операционной системы | Каждая виртуальная машина имеет отдельную ОС |Каждый контейнер может совместно использовать ОС|
| Загружается в считанные минуты |Загружается в считанные секунды |
| Виртуальные машины занимают несколько ГБ |Контейнеры легкие (КБ / МБ) |
| Готовые виртуальные машины трудно найти |Готовые док-контейнеры легко доступны|
| Виртуальные машины могут легко перейти на новый хост |Контейнеры уничтожаются и воссоздаются, а не перемещаются|
| Создание ВМ занимает относительно больше времени |Контейнеры могут быть созданы в считанные секунды|
| Больше использования ресурса |Меньшее использование ресурсов|

## Что такое Docker Compose?

__Docker-compose__ — это надстройка над докером, приложение написанное на Python, которое позволяет запускать множество контейнеров одновременно и маршрутизировать потоки данных между ними.

Для каждого проекта (кластера контейнеров) Docker создаёт свою сеть, где контейнеры могут обращаться друг к другу по именам, которые мы укажем в docker-compose.yml. Все настройки запуска кластера контейнеров находятся в этом же файле, который располагается в корневой директории проекта.

Docker-compose.yml мало чем похож на знакомые нам уже docker-файлы. В отличие от них, docker-compose.yml записан не в декларативном ini-стиле как docker-файлы, а в древовидном YAML. Если вы ещё не знакомы с YAML — рекомендуем потратить 10-15 минут и ознакомиться с нашим кратким мануалом по YAML. С ним всё нижеизложенное станет куда более понятным.

Docker Compose позволяет управлять набором контейнеров, каждый из которых представляет собой один сервис проекта. Управление включает в себя сборку, запуск с учетом зависимостей и конфигурацию. Конфигурация Docker Compose описывается в файле docker-compose.yml, лежащем в корне проекта.

Пример файла docker-compose.yml

```
# Версия схемы, которую мы используем.
# Зависит от установленной версии docker
# https://docs.docker.com/compose/compose-file/
version: "3"
# Определяем список сервисов — services
# Эти сервисы будут частью нашего приложения
services:

  app: # Имя сервиса
    build:
      # Контекст для сборки образа,
      # в данном случае, текущая директория
      context: .
      # Имя Docker-файла из которого будет собран образ
      dockerfile: Dockerfile
      # Команда, которая будет выполнена после старта сервиса
    command: make start
    ports: # Проброс портов
      - "3000:8000"
    # Перечисляем тома (volumes)
    # Они будут подключены к файловой системе сервиса
    # Например, все что находится в . мы увидим в директории /app
    volumes:
      # Текущая директория пробрасывается в директорию /app внутри контейнера
      # Путь внутри контейнера (после двоеточия) обязательно должен быть абсолютным
      - ".:/app"
      - "/tmp:/tmp"
    # Сервис будет запущен, только после старта db
    depends_on:
      - db

  db:
    # Имя образа. Здесь мы используем базу данных Postgres
    image: postgres:latest
    environment:
      # А так задаются переменные окружения
      POSTGRES_PASSWORD: password
    volumes:
      - pgdata:/var/lib/postgresql/data

  volumes:
    pgdata:
```

Команды для работы с Docker Compose
 Собирает сервисы, описанные в конфигурационных файлах
**docker compose build**

 Запускает собранные сервисы
**docker compose up**

 Запуск контейнеров на фоне с флагом -d
docker compose up -d

 Если какой-то из сервисов завершит работу,
 то остальные будут остановлены автоматически
**docker compose up --abort-on-container-exit**

 Запустит сервис application и выполнит внутри команду make install
**docker compose run application make install**

 А так мы можем запустить сервис и подключиться к нему с помощью bash
**docker compose run application bash**

 Со флагом --rm запускаемые контейнеры будут автоматически удаляться
**docker compose run --rm application bash**

 Останавливает и удаляет все сервисы,
 которые были запущены с помощью up
**docker compose down**

## Что такое Kubernetes? Для чего он используется?


ubernetes является проектом с открытым исходным кодом, предназначенным для управления кластером контейнеров Linux как единой системой. Kubernetes управляет и запускает контейнеры Docker на большом количестве хостов, а так же обеспечивает совместное размещение и репликацию большого количества контейнеров. Проект был начат Google и теперь поддерживается многими компаниями, среди которых Microsoft, RedHat, IBM и Docker.

Компания Google пользуется контейнерной технологией уже более десяти лет. Она начинала с запуска более 2 млрд контейнеров в течение одной недели. С помощью проекта Kubernetes компания делится своим опытом создания открытой платформы, предназначенной для масштабируемого запуска контейнеров.

Проект преследует две цели. Если вы пользуетесь контейнерами Docker, возникает следующий вопрос о том, как масштабировать и запускать контейнеры сразу на большом количестве хостов Docker, а также как выполнять их балансировку. В проекте предлагается высокоуровневый API, определяющее логическое группирование контейнеров, позволяющее определять пулы контейнеров, балансировать нагрузку, а также задавать их размещение.

Концепции Kubernetes

Nodes (node.md): Нода это машина в кластере Kubernetes.
Pods (pods.md): Pod это группа контейнеров с общими разделами, запускаемых как единое целое.
Replication Controllers (replication-controller.md): replication controller гарантирует, что определенное количество «реплик» pod'ы будут запущены в любой момент времени.
Services (services.md): Сервис в Kubernetes это абстракция которая определяет логический объединённый набор pod и политику доступа к ним.
Volumes (volumes.md): Volume(раздел) это директория, возможно, с данными в ней, которая доступна в контейнере.
Labels (labels.md): Label'ы это пары ключ/значение которые прикрепляются к объектам, например pod'ам. Label'ы могут быть использованы для создания и выбора наборов объектов.
Kubectl Command Line Interface (kubectl.md): kubectl интерфейс командной строки для управления Kubernetes.

Архитектура Kubernetes

Работающий кластер Kubernetes включает в себя агента, запущенного на нодах (kubelet) и компоненты мастера (APIs, scheduler, etc), поверх решения с распределённым хранилищем. Приведённая схема показывает желаемое, в конечном итоге, состояние, хотя все ещё ведётся работа над некоторыми вещами, например: как сделать так, чтобы kubelet (все компоненты, на самом деле) самостоятельно запускался в контейнере, что сделает планировщик на 100% подключаемым.
Нода Kubernetes

При взгляде на архитектуру системы мы можем разбить его на сервисы, которые работают на каждой ноде и сервисы уровня управления кластера. На каждой ноде Kubernetes запускаются сервисы, необходимые для управления нодой со стороны мастера и для запуска приложений. Конечно, на каждой ноде запускается Docker. Docker обеспечивает загрузку образов и запуск контейнеров.

Kubelet

Kubelet управляет pod'ами их контейнерами, образами, разделами, etc.

Kube-Proxy

Также на каждой ноде запускается простой proxy-балансировщик. Этот сервис запускается на каждой ноде и настраивается в Kubernetes API. Kube-Proxy может выполнять простейшее перенаправление потоков TCP и UDP (round robin) между набором бэкендов.

Компоненты управления Kubernetes

Система управления Kubernetes разделена на несколько компонентов. В данный момент все они запускаются на мастер-ноде, но в скором времени это будет изменено для возможности создания отказоустойчивого кластера. Эти компоненты работают вместе, чтобы обеспечить единое представление кластера.

etcd

Состояние мастера хранится в экземпляре etcd. Это обеспечивает надёжное хранение конфигурационных данных и своевременное оповещение прочих компонентов об изменении состояния.

Kubernetes API Server

Kubernetes API обеспечивает работу api-сервера. Он предназначен для того, чтобы быть CRUD сервером со встроенной бизнес-логикой, реализованной в отдельных компонентах или в плагинах. Он, в основном, обрабатывает REST операции, проверяя их и обновляя соответствующие объекты в etcd (и событийно в других хранилищах).

Scheduler

Scheduler привязывает незапущенные pod'ы к нодам через вызов /binding API. Scheduler подключаем; планируется поддержка множественных scheduler'ов и пользовательских scheduler'ов.

Kubernetes Controller Manager Server

Все остальные функции уровня кластера представлены в Controller Manager. Например, ноды обнаруживаются, управляются и контролируются средствами node controller. Эта сущность в итоге может быть разделена на отдельные компоненты, чтобы сделать их независимо подключаемыми.

ReplicationController — это механизм, основывающийся на pod API. В конечном счете планируется перевести её на общий механизм plug-in, когда он будет реализован.

Пример настройки кластера

В качестве платформы для примера настройки была выбрана Ubuntu-server 14.10 как наиболее простая для примера и, в то же время, позволяющая продемонстрировать основные параметры настройки кластера.

Для создания тестового кластера будут использованы три машины для создания нод и отдельная машина для проведения удалённой установки. Можно не выделять отдельную машину и производить установку с одной из нод.
