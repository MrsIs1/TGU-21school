# Задание №1. Алгоритмы балансировки нагрузки

Балансировка нагрузки предполагает, что у вебмастера есть в распоряжении несколько серверов (реальных или виртуальных), образующих кластер. Набор серверов, используемых для обслуживания одного сайта, также называют пулом. Метод балансировки позволяет распределять нагрузку между серверами из пула.

В дополнение к основному серверу портала владелец сайта подключает пул серверов для балансировки. Каждый запрос пользователя проходит через набор алгоритмов, которые выбирают, на какой сервер направить текущего посетителя. Например, можно задать простой алгоритм и направлять каждого посетителя сайта на сервер с минимальной на текущий момент загруженностью.

__Выравнивание нагрузки (load balancing)__ -комплекс методов, которые повышают отказоустойчивость сайта, увеличивают его быстродействие, упрощают горизонтальное масштабирование кластера и позволяют делать резервные копии на нескольких серверах сразу.

Большая нагрузка на сервер хостинга может навредить и сайтам-соседям. Поэтому большинство хостеров предлагают готовые решения по определению и балансировке загруженности.

Процедура балансировки осуществляется при помощи целого комплекса алгоритмов и методов, соответствующим следующим уровням модели OSI:

- **сетевому** ( нужно сделать так, чтобы за один конкретный IP-адрес сервера отвечали разные физические машины. Такая балансировка может осуществляться с помощью множества разнообразных способов. Например, DNS-балансировка
 `[На одно доменное имя выделяется несколько IP-адресов. Сервер, на который будет направлен клиентский запрос, обычно определяется с помощью алгоритма Round Robin]`, Построение NLB-кластера `[При использовании этого способа серверы объединяются в кластер, состоящий из входных и вычислительных узлов. Распределение нагрузки осуществляется при помощи специального алгоритма. Используется в решениях от компании Microsoft.]`, Балансировка по IP с использованием дополнительного маршрутизатора, Балансировка по территориальному признаку`[осуществляется путём размещения одинаковых сервисов с одинаковыми адресами в территориально различных регионах Интернета ]`);

- **транспортному** (Этот вид балансировки является самым простым: клиент обращается к балансировщику, тот перенаправляет запрос одному из серверов, который и будет его обрабатывать. Выбор сервера, на котором будет обрабатываться запрос, может осуществляться в соответствии с самыми разными алгоритмами (об этом ещё пойдёт речь ниже): путём простого кругового перебора, путём выбора наименее загруженного сервера из пула и т.п.);

- **прикладному** (При балансировке на прикладном уровне балансировщик работает в режиме «умного прокси». Он анализирует клиентские запросы и перенаправляет их на разные серверы в зависимости от характера запрашиваемого контента. Так работает, например, веб-сервер Nginx, распределяя запросы между фронтендом и бэкендом. За балансировку в Nginx отвечает модуль Upstream.).



**Round Robin**

Round Robin, или алгоритм кругового обслуживания, представляет собой **перебор по круговому циклу**: первый запрос передаётся одному серверу, затем следующий запрос передаётся другому и так до достижения последнего сервера, а затем всё начинается сначала.

Самой распространёной имплементацией этого алгоритма является, конечно же, метод балансировки Round Robin DNS. Как известно, любой DNS-сервер хранит пару «имя хоста — IP-адрес» для каждой машины в определённом домене. Этот список может выглядеть, например, так:

`example.com	xxx.xxx.xxx.2
www.example.com	xxx.xxx.xxx.3`

DNS-сервер проходит по всем записям таблицы и отдаёт на каждый новый запрос следующий IP-адрес: например, на первый запрос — xxx.xxx.xxx.2, на второй — ххх.ххх.ххх.3, и так далее. В результате все серверы в кластере получают одинаковое количество запросов.

__В числе несомненных плюсов этого алгоритма следует назвать:__
- независимость от протокола высокого уровня. Для работы по алгоритму Round Robin **используется любой протокол, в котором обращение к серверу идёт по имени.**
- Балансировка на основе алгоритма Round Robin **никак не зависит от нагрузки на сервер**: кэширующие DNS-серверы помогут справиться с любым наплывом клиентов.
- Использование алгоритма Round Robin **не требует связи между серверами**, поэтому он может использоваться как для локальной, так и для глобальной балансировки.
- решения на базе алгоритма Round Robin **отличаются низкой стоимостью**: чтобы они начали работать, достаточно просто добавить несколько записей в DNS.

__Недостатки Round Robin:__
- Чтобы распределение нагрузки по этому алгоритму отвечало упомянутым выше критериями справедливости и эффективности, нужно, чтобы у каждого сервера был в **наличии одинаковый набор ресурсов**.
- при балансировке по алгоритму Round Robin совершенно не учитывается загруженность того или иного сервера в составе кластера.


**Weighted Round Robin** (взвешенный круговой выбор): **запрос отправляется на сервер на основе веса**, заданного для каждого сервера. Этот алгоритм обеспечивает балансировку нагрузки **на основе относительной мощности каждого сервера**. Основная идея этого алгоритма заключается в том, что серверы с большими весами будут получать больший объем запросов, чем серверы с меньшими весами.

_Основные преимущества алгоритма WRR включают:_
- Простота реализации и настройки. Этот алгоритм не требует сложной конфигурации и может быть легко настроен для обеспечения оптимальной производительности.
- Гибкость. Веса могут быть легко изменены для управления объемом запросов, который отправляется на каждый сервер.

Однако, _алгоритм WRR также имеет некоторые недостатки:_
- Нет учета текущей загрузки серверов. Если серверы имеют разную производительность, то сервер с более высокой производительностью может быть перегружен, в то время как сервер с более низкой производительностью может быть недогружен.
- Нет учета задержки между серверами. Если серверы находятся в разных географических местах, то задержка между ними может быть разной. Это может привести к тому, что запросы будут обрабатываться медленнее, чем ожидалось.
- Нет учета динамических изменений. Если один из серверов выходит из строя или добавляется новый сервер, то алгоритм WRR не учитывает эти изменения, что может привести к перегрузке или недогрузке серверов.

В целом, алгоритм WRR является простым и гибким решением для балансировки нагрузки, но может быть неэффективным в некоторых сценариях, особенно когда серверы имеют разную производительность или находятся в разных географических местах. Поэтому, перед использованием этого алгоритма, необходимо тщательно оценить его преимущества и недостатки в контексте конкретного приложения.


**Least Response Time (LRT)** - это алгоритм балансировки нагрузки, который выбирает сервер с наименьшим временем ответа на запросы. Он основан на предположении, что сервер с наименьшим временем ответа имеет наибольшую производительность и меньше всего занят.

_Основные преимущества алгоритма LRT включают:_
- Высокая эффективность. Этот алгоритм позволяет минимизировать время ответа на запросы, так как запросы будут отправляться на сервер с наименьшим временем ответа.
- Адаптивность. Алгоритм LRT учитывает текущую загрузку серверов и выбирает сервер с наименьшей загрузкой.

_Алгоритм LRT также имеет некоторые недостатки:_
- Неэффективность при низкой загрузке. Если серверы имеют низкую загрузку, то выбор сервера на основе наименьшей задержки может быть неэффективным.
- Высокая чувствительность к задержкам сети. Алгоритм LRT может быть чувствителен к задержкам сети и может выбрать сервер с более низкой задержкой, но более высокой степенью нагрузки.
- Необходимость обработки большого количества запросов. Алгоритм LRT может быть неэффективным при обработке большого количества запросов, поскольку он требует вычисления задержки для каждого сервера перед выбором наилучшего сервера.

В целом, алгоритм Least Response Time является эффективным решением для балансировки нагрузки в большинстве случаев, особенно когда серверы имеют одинаковую производительность и количество клиентов не слишком большое. Однако, прежде чем использовать этот алгоритм, необходимо тщательно оценить его преимущества и недостатки в контексте конкретного приложения и выбрать наиболее подходящее решение для балансировки нагрузки.


Алгоритм балансировки нагрузки **Sticky Sessions** - это техника, которая использует информацию сессии для определения того, какой сервер должен обрабатывать запросы клиента. Она основана на том, что после того, как клиент подключается к серверу, ему присваивается уникальный идентификатор сессии, который сохраняется на сервере.

_Основные преимущества алгоритма Sticky Sessions включают:_
- Эффективность. Sticky Sessions может быть эффективным решением для балансировки нагрузки в тех случаях, когда клиентские запросы связаны с определенной сессией или состоянием сервера. Таким образом, использование Sticky Sessions может уменьшить количество запросов, которые перенаправляются на другие серверы.
- Гибкость. Sticky Sessions позволяет клиентам сохранять свое состояние на одном сервере, что может быть полезным для приложений, которые требуют сохранения состояния между запросами.

_Sticky Sessions также имеет некоторые недостатки:_
- Неравномерность распределения нагрузки. Sticky Sessions может привести к тому, что запросы будут отправляться на один и тот же сервер, что может привести к перегрузке этого сервера и недогрузке других серверов.
- Сложность масштабирования. Sticky Sessions может быть сложным для масштабирования в тех случаях, когда число клиентов или серверов увеличивается. Это может привести к тому, что серверы будут перегружены, что в свою очередь может привести к ухудшению производительности.
- Проблемы с отказоустойчивостью. Если сервер, на котором хранится информация о сессии, выходит из строя, то клиент будет вынужден повторно аутентифицироваться и начать новую сессию на другом сервере.

В целом, алгоритм Sticky Sessions является эффективным решением для балансировки нагрузки, если он используется в правильных условиях. Но перед его использованием необходимо тщательно оценить его преимущества и недостатки в контексте конкретного приложения и выбрать наиболее подходящее решение для балансировки нагрузки.


**Destination Hash Scheduling и Source Hash Scheduling**


Алгоритм Destination Hash Scheduling был создан для работы с кластером кэширующих прокси-серверов, но он часто используется и в других случаях. В этом алгоритме сервер, обрабатывающий запрос, выбирается из статической таблицы по IP-адресу получателя.<br>
_Основные преимущества алгоритма Destination Hash Scheduling включают:_
- Эффективность. Destination Hash Scheduling предоставляет эффективный способ балансировки нагрузки между серверами и обеспечивает равномерное распределение нагрузки между ними.
- Гибкость. Destination Hash Scheduling легко настраивается и может быть использован с различными типами приложений и протоколов.
- Совместимость. Destination Hash Scheduling может быть использован вместе с другими алгоритмами балансировки нагрузки, такими как Round Robin или Least Connections.<br>

_Недостатки алгоритма Destination Hash Scheduling:_
- Зависимость от хеш-функции. Качество и эффективность алгоритма Destination Hash Scheduling зависят от используемой хеш-функции. Если хеш-функция не является достаточно эффективной, то это может привести к неравномерному распределению нагрузки между серверами.
- Сложность масштабирования. Destination Hash Scheduling может быть сложным для масштабирования в тех случаях, когда число клиентов или серверов увеличивается. Это может привести к тому, что серверы будут перегружены, что в свою очередь может привести к ухудшению производительности.


Алгоритм Source Hash Scheduling основывается на тех же самых принципах, что и предыдущий, только сервер, который будет обрабатывать запрос, выбирается из таблицы по IP-адресу отправителя.<br>
_Основные преимущества алгоритма Source Hash Scheduling включают:_
- Эффективность. Source Hash Scheduling может быть эффективным решением для балансировки нагрузки в тех случаях, когда количество клиентов большое и они находятся за NAT-шлюзами. Этот алгоритм обеспечивает равномерное распределение нагрузки между серверами и уменьшает вероятность перегрузки сервера.
- Гибкость. Source Hash Scheduling позволяет клиентам сохранять свое состояние на одном сервере, что может быть полезным для приложений, которые требуют сохранения состояния между запросами.
- Простота реализации. Source Hash Scheduling не требует сложной конфигурации и может быть легко настроен для обеспечения оптимальной производительности.<br>

_Недостатки Source Hash Scheduling:_
- Не учитывает перегрузку серверов. Если сервер перегружен, то его время ответа может значительно увеличиться. Но алгоритм Source Hash Scheduling не учитывает этот фактор, что может привести к тому, что запросы будут отправляться на перегруженный сервер.
- Не учитывает динамические изменения. Если один из серверов выходит из строя или добавляется новый сервер, то алгоритм Source Hash Scheduling не учитывает эти изменения, что может привести к перегрузке или недогрузке серверов.

