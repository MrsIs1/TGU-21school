# Задание №2. Архитектура

1. Уровни архитектуры веб-приложений
Существует четыре общих уровня веб-приложений:

- Уровень представления (Presentation layer-PL)
- Уровень обслуживания данных (Data Service Layer-DSL)
- Уровень бизнес-логики (Business Logic Layer-BLL)
- Уровень доступа к данным (Data Access Layer-DAL)

__Уровень представления__
PL отображает пользовательский интерфейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показывают данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодействие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления - получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.

__Слой бизнес-логики__
BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Вход на сайт - это пример уровня бизнес-логики.

__Уровень службы данных__
DSL передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.

__Уровень доступа к данным__
DAL предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD - создание, чтение, обновление, удаление.
 
## Что такое монолитная и микросервисная архитектуры веб-приложения
__Монолитная архитектура__ — это традиционная модель программного обеспечения, которая представляет собой единый модуль, работающий автономно и независимо от других приложений. Монолитная архитектура — это отдельная большая вычислительная сеть с единой базой кода, в которой объединены все бизнес-задачи. Чтобы внести изменения в такое приложение, необходимо обновить весь стек через базу кода, а также создать и развернуть обновленную версию интерфейса, находящегося на стороне службы. Это ограничивает работу с обновлениями и требует много времени. 
Монолиты удобно использовать на начальных этапах проектов, чтобы облегчить развертывание и не тратить слишком много умственных усилий при управлении кодом. Это позволяет сразу выпускать все, что есть в монолитном приложении.

__Микросервисная архитектура__ представляет собой метод организации архитектуры, основанный на ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью. Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы. 
Микросервисы разбивают крупные задачи, характерные для конкретного бизнеса, на несколько независимых баз кода. Микросервисы не снижают сложность, но они делают любую сложность видимой и более управляемой, разделяя задачи на более мелкие процессы, которые функционируют независимо друг от друга и вносят вклад в общее целое. 


__Монолиты__ - Это приложения, построенные как единое целое, где вся логика по обработке запросов помещается внутрь одного процесса. Разумеется, монолиты могут иметь модульную структуру — содержать отдельные классы, функции, namespace (в зависимости от выбранного языка программирования). Но связи между этими модулями настолько сильны, что изменение каждого из них неизбежно отражается на работе приложения в целом.

__Например__
Представим кирпичную стену. Она возводится из отдельных блоков. При строительстве кирпичи еще отделимы друг от друга, но со временем, когда цемент затвердевает, они становятся неразрывно связаны. Вы можете продолжить стену в одном из направлений, но для того, чтобы коренным образом изменить ранее построенное, скорее всего, придется применить кувалду.

Рассмотрим для примера типичный интернет-магазин. Монолитное приложение для него будет использовать трехуровневую архитектуру, включающую:

- пользовательский интерфейс;

- серверную часть, отвечающую за бизнес-логику приложения и доступ к данным;

- базу данных.

Бизнес-функции приложения очень разнообразны: работа с каталогом товаров и корзиной, обработка заказов, их оплата и отслеживание статуса, ведение пользователей и так далее. Но на уровне приложения все они объединены в один монолитный блок. При разворачивании код для различных функций находится на одном сервере. Чтобы масштабировать приложение, необходимо запустить несколько его экземпляров на различных физических серверах.

__Недостатки схемы монолитной архитектуры:__


- Избыточность сборок и развертывания. Даже небольшое изменение для одной из бизнес-функций будет приводить к необходимости сборки и развертывания новой версии всего приложения.


- Невозможность масштабирования части приложения. Масштабировать приходится все приложение целиком, даже если это необходимо отдельно взятому компоненту с наименьшей производительностью. Можно предположить, что обращения к каталогу товаров будут происходить значительно чаще оформления заказов — то есть именно для этой функции стоило бы выделить дополнительные ресурсы, но в монолите это невозможно.

- Увеличение цены сбоя. Отказ одного модуля чаще всего сказывается на всей работе в целом в силу тесных связей внутри приложения.
 
- Сложность внедрения новых технологий. Разработчик ограничен выбранным для приложения технологическим стеком. Хотя для ряда компонентов, возможно, было бы эффективно использовать иные технологии.

- Организационные сложности. Требуется большая команда, которой тяжело управлять. При этом структура команды, вероятнее всего, будет соответствовать выбранной архитектуре: отдельные специалисты по пользовательскому интерфейсу, бизнес-логике и базе данных. И каждой из этих групп потребуется владеть экспертизой по всем бизнес-функциям, что со временем будет становиться все труднее.
 
- Редкость обновлений. Так как изменения затрагивают все приложение, увеличивается время на их отладку и проверку, что приводит к редким выходам обновлений и увеличению числа выпускаемых изменений в одном релизе, а это, в свою очередь, повышает риски.
 
- Сильная зависимость от модели данных. Любое изменение в базе данных будет сказываться на всем приложении и требовать значительных изменений кода.
 Для небольших и редко обновляемых приложений такая архитектура может работать прекрасно. Но по мере наращивания функциональности межмодульные связи в монолите будут неизбежно увеличиваться и усложняться, изменения в одних модулях будут все больше влиять на другие — в итоге дальнейшее развитие таких систем становится крайне затруднительным. И вот тут самое время присмотреться к микросервисам.


В отличие от монолитов, в __микросервисной__ архитектуре приложение строится как набор небольших и слабосвязанных компонентов (микросервисов), которые можно разрабатывать, развертывать и поддерживать независимо друг от друга.

__Например__
Если монолитное приложение проще всего сравнить с кирпичной кладкой, то микросервисы похожи на всем знакомый конструктор Lego. У вас есть множество деталей с четкими стандартными границами для соединения друг с другом. Вы всегда можете пересобрать получившееся изделие, заменив или убрав какие-то из элементов без ущерба для остальных.

Каждый из сервисов отвечает за конкретную бизнес-задачу, имеет собственное хранилище данных и общается с другими сервисами через простые API-интерфейсы для решения более сложных задач. Так, в нашем примере можно выделить микросервисы по ведению каталога товаров, работе с корзиной, оформлению заказов, оплате и так далее.

<i>Ключевые преимущества микросервисов по сравнению с монолитами:</i>

1. Простота развертыванияМожно развертывать только изменяющиеся микросервисы, независимо от остальной системы, что позволяет производить обновления чаще и быстрее.
2. Оптимальность масштабированияМожно расширять только те сервисы, которые в этом нуждаются, то есть сервисы с наименьшей производительностью, оставляя работать остальные части системы на менее мощном оборудовании.
 
3. Устойчивость к сбоямОтказ одного сервиса не приводит к остановке системы в целом. Когда же ошибка исправлена, необходимое изменение можно развернуть только для соответствующего сервиса — вместо повторного развертывания всего приложения. Правда, для этого еще на этапе проектирования микросервисов потребуется тщательно продумать связи между ними для достижения максимальной независимости друг от друга, а также заложить возможность корректного оповещения пользователя о временной недоступности определенного сервиса без ущерба для всей системы.
 
4. Возможность выбора технологийМожно подбирать различные наборы технологий, оптимальные для решения задач, стоящих перед отдельными сервисами.

5. Небольшие команды разработкиПри разработке микросервисов команды принято закреплять за конкретными бизнес-задачами (и сервисами, соответственно)Такие команды, как правило, показывают большую эффективность, а управлять ими легче.

6. Уменьшение дублирования функциональностейПрисутствует возможность повторного использования функциональности для различных целей и различными способами.

7. Упрощение замены сервисов при необходимостиНебольшие сервисы проще заменить на более подходящую версию или удалить вовсе — это несет значительно меньше рисков по сравнению с монолитным приложением.

8. Независимость моделей данныхКаждый микросервис, как правило, использует собственное хранилище данных — поэтому изменение модели данных в одном сервисе не влияет на работу остальных.

<i>Не все ПО построены на микросервисной архитектуре потому, что она имеет ряд недостатков:</i>


1. Распределенная система
Микросервисы по своей природе распределены, а это, как известно, имеет свои недостатки: удаленные вызовы медленнее и чаще подвержены сбоям. Если ваш микросервис обращается к десятку других микросервисов, а те, в свою очередь, вызывают еще несколько, то итоговое время отклика значительно возрастает. Также по мере увеличения взаимодействий микросервисов друг с другом возрастает и число возможных точек отказа.

- Известны несколько путей решения этой проблемы:
Первый — изменить детализацию своих вызовов таким образом, чтобы сократить их количество.
Второй — использовать асинхронность: при параллельном выполнении нескольких вызовов конечное время отклика будет определяться самым медленным из них, а не суммой всех задержек.
Оба метода усложняют модель программирования и увеличивают требования к квалификации.

2. Усложнение процессов и повышение требований к команде
Рост числа небольших независимых сервисов неизбежно увеличивает операционную сложность. Возрастает роль непрерывной интеграции и доставки, ведь невозможно обрабатывать десятки услуг без автоматизации их тестирования и развертывания. Повышаются требования к мониторингу, особенно в силу технологической разнородности сервисов.

- Чтобы справиться с возросшей нагрузкой, компании нужно овладеть целым рядом новых навыков и инструментов, и важнейший из них — внедрение культуры DevOps. Необходимо обеспечить тесное сотрудничество программистов, тестировщиков, инженеров сопровождения и прочих участников разработки продукта на всех этапах его жизненного цикла. Далеко не все организации смогут справиться с таким количеством изменений. Но культурные изменения необходимы.

- Если разработка монолитных приложений без повышения квалификации и овладения новыми навыками со временем становится затруднительной, но разработка микросервисов — вовсе невозможна.

3. Необходимость поддержания согласованности приложения
Микросервисы порождают возможные проблемы с согласованностью из-за применяемого в них децентрализованного управления данными. В монолитном приложении можно выполнить множество связанных изменений за одну транзакцию, и вы будете уверены, что в случае сбоя произойдет откат и согласованность данных сохранится.

- Микросервисам же требуется несколько ресурсов для выполнения цепочки изменений, распределенные транзакции не приветствуются — поэтому может возникнуть ситуация, когда при обновлении одного компонента временно перестанет отвечать другой, ожидая завершения операции на первом.

- Конечно, при разработке определенных сервисов можно отдать предпочтение не согласованности, а доступности: чтобы в случае обновления или выхода из строя одного сервиса, другие продолжали работу. Но делать это нужно крайне осторожно, чтобы бизнес-логика не принимала решений на основе противоречивой информации.

__Важно__
То есть разработчикам необходимо всегда помнить о проблеме конечной согласованности, находить компромисс между доступностью и согласованностью и предотвращать возможные случаи рассинхронизации данных.
Таким образом, при <i>неоправданном использовании микросервисов многие их преимущества могут быть сведены на нет</i>. Поэтому большинство специалистов советуют начинать с монолита, поддерживая его модульность, а к микросервисам переходить при появлении потребности в них и после проведения предварительной подготовки.

Кому не обойтись без микросервисов:

- Большая команда: если у вас работает больше 10 человек, команда растет, все сложнее погружать новичков целиком в предметную область, то микросервисы помогут стандартизировать разработку и упростить командную работу.

- Множество взаимодействующих модулей в приложении: если их количество измеряется десятками, однозначно стоит задуматься о микросервисах.
- Объемный код: приложение с многомиллионными строками кода со временем все тяжелее поддерживать и развивать как монолит.

- Долгое время запуска приложений (полчаса и более): переход на микросервисы позволит устранить вынужденные простои и эффективно использовать время разработчиков.

- Различные требования к ресурсам в рамках одного приложения: использование микросервисов идеально в случаях, когда у разных компонентов отличаются требования к ЦП, памяти и так далее.

- Для вашего бизнеса критична непрерывная доставка: если необходимо обеспечить своевременный выход обновлений, микросервисы являются предпочтительным вариантом, так как по скорости развертывания они значительно лучше монолитов.

- Высокий трафик со склонностью к периодическим всплескам нагрузки: микросервисы отлично сочетаются с автомасштабированием и облачной моделью, которые позволят использовать ресурсы только тогда, когда в них есть необходимость.

## Какие особенности тестирования монолитных и микросервисных веб-приложений?

## Юнит тестрирование монолитной архитектуры веб-приложений
В случае монолитной архитектуры возникает проблемы с поддержанием и написанием
юнит-тестов. На начальных этапах жизни приложения данное тестирование не
представляет никаких трудностей, однако по мере роста кодовой базы
приложения возникают проблемы с поддержкой. Из-за большой кодовой базы
бывает сложно найти, разобраться и поправить определенный юнит-тест или
написать новый. В результате в какой-то момент возникает ситуация, когда
есть большая кодовая база, которая частично покрыта юнит-тестами, часть из
которых может быть не актуализирована под новый функционал, а на часть
функционала вообще нет тестов.
## Автотестирование монолитной архитектуры веб-приложений
 Данный вид тестирования сталкивается с теми же проблемами, что и
юнит-тестирование: сложность разработки при большой кодовой базе. Из-за
обилия бизнес-логики в монолите приложения, написать и поддержать
автотесты на весь функционал проблематично, так как изменение какой-либо
части бизнес-логики потребует исправлений во всех автотестах, в которых
использует данный кусок логики
## Интеграционное тестирование монолитной архитектуры веб-приложений
Вид тестирования, в котором проверяется
взаимодействие сервиса при работе с другими сервисами. Интеграционное
тестирование может являться частью авто-тестирования. Примером
интеграционного тестирования может быть проверка возможности получения
каких-либо данных из базы данных. Так как в монолитной архитектуре все
сосредоточенно в одном сервисе, то интеграционное тестирование может
сводиться к проверке поведения при работе с серверами баз данных.
## Нагрузочное тестирование монолитной архитектуры веб-приложений
Необходимость данного вида тестирования
заключается в том, что при неспособности системы выдержать большое
количество запросов, запросы от пользователей в лучшем случае будут
попадать в очередь и выполняться по мере обработки остальных запросов из
очереди. Это приведет к увеличению времени обработки запроса. В худшем
случае система вообще перестанет работать при достижении определенной
нагрузки. В подавляющем большинстве базы данных являются тем местом,
скорость работы которого сильно зависит от нагрузки. Поэтому в первую
очередь именно на них необходимо смотреть при запуске нагрузочных тестов.
В результате можно увидеть, что проблема при тестировании монолитной
архитектуры сводится к большому количеству элементов, которые необходимо
проверить. В определенный момент становится достаточно сложно поддержать
и обеспечить необходимое качество приложения, использующего подход
монолитной архитектуры
## Юнит тестирование микросервисной архитектуры веб-приложений
Микросервисы, в отличие от монолита, имеют меньшую кодовую базу, а
это значит, что покрыть микросервис юнит-тестами и поддерживать их
значительно проще.
## Авто-тестирование микросервисной архитектуры веб-приложений
Из-за того, что микросервис содержит
только часть бизнес-логики приложения, покрыть эту часть автотестами,
которые будут выполняться только в рамках этого микросервиса, гораздо
проще.
Однако, в случае покрытия самого сервиса тестами, необходимо также
убедиться, что само приложение в связке всех микросервисов работает
правильно. Для этого необходимо также написать автотесты, которые
повторяют основные сценарии пользователя
## Интеграционное тестирование микросервисной архитектуры веб-приложений
В отличие от монолитной архитектуры, важность интеграционного
тестирования становится более весомой. Так как сетевое взаимодействие -
единственный вид взаимодействия между микросервисами, интеграционному
тестированию необходимо уделить большее внимание, чем в монолите. В тестплан для интеграционного тестирования входит проверка возможности
взаимодействия с другими микросервисами, а также результат этого
взаимодействия. Это может взаимодействие как между Main Service и любым
из сервисов , так и взаимодействие сервисов между собой. По
результатам интеграционного тестирования можно судить о доступности
микросервиса другим микросервисам.
## Нагрузочное тестирование микросервисной архитектуры веб-приложений
Помимо возросшей важности интеграционных тестов, также возрастает
необходимость в правильно составленных нагрузочных тестах. Кроме того, что
микросервисы общаются с базой данных, они могут общаться между собой. А
это значит, что может возникнуть ситуация, когда два микросервиса не могут
нормально общаться между собой, так как большая нагрузка между ними не
позволяет быстро обрабатывать запросы. В результате, помимо проверки
нагрузки при общении микросервисов с базой данных возникает
необходимость в проверки их общения между собой.

